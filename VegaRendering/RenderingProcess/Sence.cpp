#include "Sence.h"

CSence::CSence(const CMesh& vMesh)
{
	m_Meshes.push_back(vMesh);
}

//****************************************************************************************************
//FUNCTION:
void CSence::draw(const CShader& vShader, bool instance, std::vector<std::vector<glm::vec3>> deformationFrames)
{
	if (instance == false)
	{
		//m_Meshes[0].draw(vShader);
		//m_Meshes[1].draw(vShader);
		for (const auto& Mesh : m_Meshes)
			Mesh.draw(vShader);
	}
	else
	{
		for (int i = 0; i < 2; i++)
			for (auto& Mesh : m_Meshes)
			{
				CTreeInstanceMesh tempMesh = addDeformationData(Mesh, deformationFrames[i]);
				tempMesh.draw(vShader);
			}
	}
}
//****************************************************************************************************
//FUNCTION:
CTreeInstanceMesh CSence::addDeformationData(CMesh vMesh, std::vector<glm::vec3> deformationFrames)
{
	return CTreeInstanceMesh(vMesh, deformationFrames);
}

//通过groups获取顶点个数，将输入的deformation划分。
void CSence::SetParaMesh()
{
	for (auto i = 0; i < m_Mesh->getNumGroups(); i++)
	{

	}
}

void CSence::__changeObjMeshStruct2Charptr(int vOutputMaterials)
{
	std::string materialFilename;
	std::string materialFilenameLocal;
	//bool materialFileExist=false;

	if (vOutputMaterials && (m_Mesh->getNumMaterials() == 0))
		vOutputMaterials = 0;

	if (vOutputMaterials)
	{
		materialFilename = m_Mesh->getFilename() + ".mtl";
		// remove directory part from materialFilename
		char * materialFilenameTempC = (char*)materialFilename.c_str();
		char * beginString = materialFilenameTempC;
		// seek for last '/'
		for (unsigned int i = 0; i < strlen(materialFilenameTempC); i++)
			if ((materialFilenameTempC[i] == '/') || (materialFilenameTempC[i] == '\\'))
				beginString = &materialFilenameTempC[i + 1];

		materialFilenameLocal = std::string(beginString);
	}

	int numTriangles = 0;
	for (unsigned int i = 0; i < m_Mesh->getNumGroups(); i++)
		numTriangles += m_Mesh->getGroup(i).getNumFaces();
	std::stringstream ss;

	ss << "# Generated by the ObjMesh class"<<std::endl;
	ss << "# Number of vertices: " <<m_Mesh->getNumVertices()<< std::endl;
	ss << "# Number of texture coordinates: "<<m_Mesh->getNumTextureCoordinates()<<std::endl;
	ss << "# Number of normals: "<<m_Mesh->getNumNormals()<<std::endl;
	ss << "# Number of faces: " << numTriangles << std::endl;
	ss << "# Number of groups: "<<m_Mesh->getNumGroups()<<std::endl;

	if (vOutputMaterials)
		ss << std::endl << "mtllib " << materialFilenameLocal << std::endl << std::endl;
	
	int maxPrecision = std::numeric_limits<long double>::digits10 + 1;
	int pcs = (-1 > maxPrecision ? maxPrecision : -1);
	if (pcs > 0)
		ss << std::setprecision(pcs);
	for (unsigned int i = 0; i < m_Mesh->getNumVertices(); i++)
	{
		Vec3d pos = m_Mesh->getPosition(i);
		double x = m_RestVertexs[3 * i + 0];
		double y = m_RestVertexs[3 * i + 1];
		double z = m_RestVertexs[3 * i + 2];
		ss << "v " << (pos[0]-x) << " " << (pos[1]-y) << " " << (pos[2]-z) << std::endl;
	}
	for (unsigned int i = 0; i < m_Mesh->getNumTextureCoordinates(); i++)
	{
		Vec3d texCoord_ = m_Mesh->getTextureCoordinate(i);
		ss << "vt " << texCoord_[0] << " " << texCoord_[1] << std::endl;
	}
	// normals...
	for (unsigned int i = 0; i < m_Mesh->getNumNormals(); i++)
	{
		Vec3d normal_ = m_Mesh->getNormal(i);
		ss << "vn " << normal_[0] << " " << normal_[1] << " " << normal_[2] << std::endl;
	}
	// groups and faces...
	for (unsigned int i = 0; i < m_Mesh->getNumGroups(); i++)
	{
		ss << "g " << m_Mesh->getGroup(i).getName() << std::endl;
		if (vOutputMaterials)
		{
			ss << "usemtl " << m_Mesh->getMaterial(m_Mesh->getGroup(i).getMaterialIndex()).getName() << std::endl;
		}
		for (unsigned int iFace = 0; iFace < m_Mesh->getGroup(i).getNumFaces(); iFace++)
		{
			ObjMesh::Face face = m_Mesh->getGroup(i).getFace(iFace); // get face whose number is iFace

			ss << "f";
			if (face.getNumVertices() < 3)
				std::cout << "Warning: encountered a face (group=" << i << ",face=" << iFace << ") with fewer than 3 vertices." << std::endl;

			for (unsigned int iVertex = 0; iVertex < face.getNumVertices(); iVertex++)
			{
				ObjMesh::Vertex vertex = face.getVertex(iVertex);
				ss << " " << int(vertex.getPositionIndex() + 1);
				if (vertex.hasTextureCoordinateIndex() || vertex.hasNormalIndex())
				{
					ss << "/";
					if (vertex.hasTextureCoordinateIndex())
						ss << int(vertex.getTextureCoordinateIndex() + 1);
					if (vertex.hasNormalIndex())
					{
						ss << "/";
						if (vertex.hasNormalIndex())
							ss << int(vertex.getNormalIndex() + 1);
					}
				}
			}
			ss << std::endl;
		}
	}
	m_Data =ss.str();
	m_DataSize = strlen((char*)ss.str().c_str());
}

//void CSence::__changeVertexStruct(ObjMesh::Group * groupHandle)
//{
//	std::vector<Common::SVertex> Vertices;
//	std::vector<unsigned int> Indices;
//	std::vector<Common::STexture> Textures;
//	
//	for (unsigned int iVertex = 0; iVertex < m_Mesh->getNumVertices; iVertex++)
//	{
//		m_Mesh->getPosition(iVertex);
//		
//	}
//	for (unsigned int iFace = 0; iFace < groupHandle->getNumFaces(); iFace++)
//	{
//		const ObjMesh::Face * faceHandle = groupHandle->getFaceHandle(iFace);
//
//		for (unsigned int iVertex = 0; iVertex < faceHandle->getNumVertices(); iVertex++)
//		{
//			const ObjMesh::Vertex * vertexHandle = faceHandle->getVertexHandle(iVertex);
//			Vec3d v = m_Mesh->getPosition(*vertexHandle);
//			int vertexPositionIndex = vertexHandle->getPositionIndex();
//
//			Indices.push_back(vertexPositionIndex);
//		}
//	}																	    
//}

//****************************************************************************************************
//FUNCTION:
void CSence::__loadModel(const std::string& vModelPath, bool vloadNormalizeModelAndFaceNormal)
{
	Assimp::Importer Importer;
	const aiScene* pScene;
	if (vloadNormalizeModelAndFaceNormal == true)
	{
		aiPropertyStore* Porps = aiCreatePropertyStore();
		aiSetImportPropertyInteger(Porps, "PP_PTV_NORMALIZE", 1);
		pScene = (aiScene*)aiImportFileExWithProperties(vModelPath.c_str(), aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_GenNormals | aiProcess_JoinIdenticalVertices | aiProcess_PreTransformVertices, NULL, Porps);
		aiReleasePropertyStore(Porps);
	}
	else
	{
		pScene = Importer.ReadFile(vModelPath, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
		if (!pScene || pScene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !pScene->mRootNode)
		{
			std::cout << "ERROR::ASSIMP:: " << Importer.GetErrorString() << std::endl;
			return;
		}
	}
	setFileDirectiory(vModelPath.substr(0, vModelPath.find_last_of('/')));
	__processNode(pScene->mRootNode, pScene,false);
}

void CSence::__loadModelFromMemory()
{
	const aiScene* pScene = NULL;
	Assimp::Importer *imp = new Assimp::Importer();
	int Flags = aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace;
	pScene = imp->ReadFileFromMemory((unsigned char*)m_Data.c_str(), m_DataSize, Flags);
	__processNode(pScene->mRootNode, pScene,true);
}

//****************************************************************************************************
//FUNCTION:
void CSence::__processNode(const aiNode* vNode, const aiScene* vScene,bool vSaveDeformationOrLoadData)
{
	for (unsigned int i = 0; i < vNode->mNumMeshes; i++)
	{
		aiMesh* Mesh = vScene->mMeshes[vNode->mMeshes[i]];
		/*auto temp = __processMesh(Mesh, vScene);
		m_Meshes.push_back(temp);*/
		if(vSaveDeformationOrLoadData==false)
		m_Meshes.push_back(__processMesh(Mesh, vScene));
		else
		{
			__processSaveDeformation(Mesh, vScene);
		}
	}
	for (unsigned int i = 0; i < vNode->mNumChildren; i++)
	{
		__processNode(vNode->mChildren[i], vScene, vSaveDeformationOrLoadData);
	}
}

//****************************************************************************************************
//FUNCTION:
CMesh CSence::__processMesh(const aiMesh* vMesh, const aiScene* vScene)
{
	std::vector<Common::SVertex> Vertices;
	std::vector<unsigned int> Indices;
	std::vector<Common::STexture> Textures;

	for (unsigned int i = 0; i < vMesh->mNumVertices; i++)
	{
		Common::SVertex Vertex;
		Vertex.Position = Common::vec3_cast(vMesh->mVertices[i]);
		Vertex.Normal = Common::vec3_cast(vMesh->mNormals[i]);
		if (vMesh->mTextureCoords[0]) // does the mesh contain texture coordinates?
		{
			glm::vec2 vec;
			vec.x = vMesh->mTextureCoords[0][i].x;
			vec.y = vMesh->mTextureCoords[0][i].y;
			Vertex.TexCoords = vec;
		}
		else
			Vertex.TexCoords = glm::vec2(0.0f, 0.0f);
		if (vMesh->HasTangentsAndBitangents())
		{
			Vertex.Tangent = Common::vec3_cast(vMesh->mTangents[i]);
			Vertex.Bitangent = Common::vec3_cast(vMesh->mBitangents[i]);
			Common::ModelHaveTangentAndBitangent = true;
		}
		else
			Common::ModelHaveTangentAndBitangent = false;
		Vertices.push_back(Vertex);
	}

	for (unsigned int i = 0; i < vMesh->mNumFaces; i++)
	{
		const aiFace Face = vMesh->mFaces[i];

		for (unsigned int k = 0; k < Face.mNumIndices; k++)
			Indices.push_back(Face.mIndices[k]);
	}
	aiMaterial* material = vScene->mMaterials[vMesh->mMaterialIndex];
	// 1. diffuse maps
	std::vector<Common::STexture> DiffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, "texture_diffuse");
	Textures.insert(Textures.end(), DiffuseMaps.begin(), DiffuseMaps.end());
	/* 2. specular maps*/
	std::vector<Common::STexture> SpecularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, "texture_specular");
	Textures.insert(Textures.end(), SpecularMaps.begin(), SpecularMaps.end());
	// 3. normal maps
	std::vector<Common::STexture> NormalMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, "texture_normal");
	Textures.insert(Textures.end(), NormalMaps.begin(), NormalMaps.end());
	////// 4. height maps
	std::vector<Common::STexture> HeightMaps = loadMaterialTextures(material, aiTextureType_AMBIENT, "texture_height");
	Textures.insert(Textures.end(), HeightMaps.begin(), HeightMaps.end());

	return CMesh(Vertices, Indices, Textures);
}

//****************************************************************************************************
//FUNCTION:
void CSence::__processSaveDeformation(const aiMesh* vMesh, const aiScene* vScene)
{
	std::vector<glm::vec3> Vertices;
	for (unsigned int i = 0; i < vMesh->mNumVertices; i++)
	{
		Vertices.push_back(Common::vec3_cast(vMesh->mVertices[i]));		
	}
	m_EachFrameOfGroupData.push_back(Vertices);	
}

//****************************************************************************************************
//FUNCTION:
unsigned int CSence::TextureFromFile(const char *vPath, const std::string &vDirectory, bool vGamma)
{
	std::string FileName = std::string(vPath);
	FileName = vDirectory + '/' + FileName;

	unsigned int textureID;
	glGenTextures(1, &textureID);

	int width, height, nrComponents;
	unsigned char *data = stbi_load(FileName.c_str(), &width, &height, &nrComponents, 0);
	if (data)
	{
		GLenum format;
		if (nrComponents == 1)
			format = GL_RED;
		else if (nrComponents == 3)
			format = GL_RGB;
		else if (nrComponents == 4)
			format = GL_RGBA;

		glBindTexture(GL_TEXTURE_2D, textureID);
		glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
		glGenerateMipmap(GL_TEXTURE_2D);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		stbi_image_free(data);
	}
	else
	{
		std::cout << "Texture failed to load at path: " << vPath << std::endl;
		stbi_image_free(data);
	}

	return textureID;
}


//****************************************************************************************************
//FUNCTION:
std::vector<Common::STexture> CSence::loadMaterialTextures(aiMaterial *vMat, aiTextureType vType, std::string vTypeName)
{
	std::vector<Common::STexture> Textures;
	for (unsigned int i = 0; i < vMat->GetTextureCount(vType); i++)
	{
		aiString str;
		vMat->GetTexture(vType, i, &str);
		// check if texture was loaded before and if so, continue to next iteration: skip loading a new texture
		bool skip = false;
		for (unsigned int j = 0; j < m_Textures.size(); j++)
		{
			if (std::strcmp(m_Textures[j].path.data(), str.C_Str()) == 0)
			{
				Textures.push_back(m_Textures[j]);
				skip = true; // a texture with the same filepath has already been loaded, continue to next one. (optimization)
				break;
			}
		}
		if (!skip)
		{   // if texture hasn't been loaded already, load it
			Common::STexture Texture;
			Texture.id = TextureFromFile(str.C_Str(), this->m_FileDirectory);
			Texture.type = vTypeName;
			Texture.path = str.C_Str();
			Textures.push_back(Texture);
			m_Textures.push_back(Texture);  // store it as texture loaded for entire model, to ensure we won't unnecesery load duplicate textures.
		}
	}
	return Textures;
}
